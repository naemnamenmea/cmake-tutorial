if(TRUE)
	function(target_link_libraries _target)
		set(_mode "PUBLIC")
		foreach(_arg IN LISTS ARGN)
			if (_arg MATCHES "INTERFACE|PUBLIC|PRIVATE|LINK_PRIVATE|LINK_PUBLIC|LINK_INTERFACE_LIBRARIES")
				set(_mode "${_arg}")
			else()
				if (NOT _arg MATCHES "debug|optimized|general")
					set_property(GLOBAL APPEND PROPERTY GlobalTargetDepends${_target} ${_arg})
				endif()
			endif()
		endforeach()
		_target_link_libraries(${_target} ${ARGN})
	endfunction()

	function(get_link_libraries _listvar _target)
		set(_worklist ${${_listvar}})
		if (TARGET ${_target})
			list(APPEND _worklist ${_target})
			get_property(_dependencies GLOBAL PROPERTY GlobalTargetDepends${_target})
			foreach(_dependency IN LISTS _dependencies)
				if (NOT _dependency IN_LIST _worklist)
					get_link_libraries(_worklist ${_dependency})
				endif()
			endforeach()
			set(${_listvar} "${_worklist}" PARENT_SCOPE)
		endif()
	endfunction()
	else()
	function(get_link_libraries OUTPUT_LIST TARGET)
		get_target_property(IMPORTED ${TARGET} IMPORTED)
		list(APPEND VISITED_TARGETS ${TARGET})
		if (IMPORTED)
			get_target_property(LIBS ${TARGET} INTERFACE_LINK_LIBRARIES)
		else()
			get_target_property(LIBS ${TARGET} LINK_LIBRARIES)
		endif()
		set(LIB_FILES "")
		foreach(LIB ${LIBS})
			if (TARGET ${LIB})
				list(FIND VISITED_TARGETS ${LIB} VISITED)
				if (${VISITED} EQUAL -1)
					get_target_property(LIB_FILE ${LIB} NAME)
					get_link_libraries(LINK_LIB_FILES ${LIB})
					list(APPEND LIB_FILES ${LIB_FILE} ${LINK_LIB_FILES})
				endif()
			endif()
		endforeach()
		set(VISITED_TARGETS ${VISITED_TARGETS} PARENT_SCOPE)
		set(${OUTPUT_LIST} ${LIB_FILES} PARENT_SCOPE)
	endfunction()
endif()

function(mw_is_target_enabled is_enabled target)
	if (TARGET ${target})
		set(${is_enabled} OFF PARENT_SCOPE)
	else()
		set(${is_enabled} ON PARENT_SCOPE)
	endif()
endfunction()

function(mw_target_end target)
	mw_target_keep_file_structure(${target})    
endfunction()

# transfer file system folders of source files into visual studio folders
function(mw_target_keep_file_structure target)
	# interface libraries don't have sources, so we have to skip them
	get_target_property(_type ${target} TYPE)
	if(NOT("${_type}" STREQUAL "INTERFACE_LIBRARY"))
		get_target_property(_sources ${target} SOURCES)

		# We can't use the native command, because some projects include files from outside their root folder
		#source_group(TREE "${CMAKE_CURRENT_SOURCE_DIR}" FILES ${_sources})

		# inspired by https://stackoverflow.com/questions/31422680/how-to-set-visual-studio-filters-for-nested-sub-directory-using-cmake
		foreach(_source ${_sources})
			if (IS_ABSOLUTE "${_source}")
				file(RELATIVE_PATH _source_rel "${CMAKE_CURRENT_SOURCE_DIR}" "${_source}")
			else()
				set(_source_rel "${_source}")
			endif()
			get_filename_component(_source_path "${_source_rel}" PATH)
			string(REPLACE "/" "\\" _source_path_msvc "${_source_path}")
			source_group("${_source_path_msvc}" FILES "${_source}")
		endforeach()
	endif()
endfunction()

# Collect all currently added targets in all subdirectories
#
# Parameters:
# - _result the list containing all found targets
# - _dir root directory to start looking from
function(mw_find_all_targets _result _dir)
	set(_all_targets)
	macro(recurse _root_dir)
		get_property(_subdirs DIRECTORY "${_root_dir}" PROPERTY SUBDIRECTORIES)
		foreach(_subdir IN LISTS _subdirs)
			recurse("${_subdir}")
		endforeach()
		get_directory_property(_sub_targets DIRECTORY "${_root_dir}" BUILDSYSTEM_TARGETS)
		list(APPEND _all_targets ${_sub_targets})
	endmacro()

	recurse("${_dir}")
	set(${_result} ${_all_targets} PARENT_SCOPE)
endfunction()

function(mw_set_default_project_filters)
	mw_find_all_targets(targets ${CMAKE_SOURCE_DIR})

	# collect list of non-interface-target directories
	set(target_dirs)
	foreach(target ${targets})
		get_target_property(library_type ${target} TYPE)
		if(${library_type} STREQUAL "INTERFACE_LIBRARY")
			continue()
		endif()
		get_target_property(target_dir ${target} SOURCE_DIR)
		list(APPEND target_dirs "${target_dir}")
	endforeach()

	foreach(target ${targets})
		# don't set folders for interface libraries (doesn't work)
		get_target_property(library_type ${target} TYPE)
		if(${library_type} STREQUAL "INTERFACE_LIBRARY")
			continue()
		endif()
		if(${library_type} STREQUAL "UTILITY")
			continue()
		endif()

		# don't overwrite folder if it was already specified manually
		get_target_property(folder_name ${target} FOLDER)
		if(folder_name)
			continue()
		endif()

		# find number of targets in the same directory
		get_target_property(target_dir ${target} SOURCE_DIR)
		set(sub_target_dirs)
		foreach(d ${target_dirs})
			if(${d} STREQUAL "${target_dir}")
				list(APPEND sub_target_dirs ${d})
			else()
				string(FIND ${d} "${target_dir}/" d_pos)
				if(d_pos GREATER -1)
					list(APPEND sub_target_dirs ${d})
				endif()
			endif()
		endforeach()
		list(LENGTH sub_target_dirs sub_target_count)

		file(RELATIVE_PATH project_filter_path ${CMAKE_SOURCE_DIR} ${target_dir})

		# skip the directory name if there is only one target in it
		if(sub_target_count EQUAL 1)
			get_filename_component(project_filter_path ${project_filter_path} DIRECTORY)
		endif()

        # message("${target}: ${project_filter_path}")
        if(NOT project_filter_path STREQUAL "")
			set(result false)
			set(prefix "../")
			cmake_path(IS_PREFIX prefix ${project_filter_path} result)
			
			if(result)
				set(outt)
				string(REPLACE "../" "" outt "${project_filter_path}")
				set(project_filter_path)
				cmake_path(APPEND project_filter_path "external_libraries" ${outt})
			endif()
            # overwrite project folder name
            set_target_properties(${target} PROPERTIES FOLDER ${project_filter_path})
        endif()
	endforeach()
endfunction()

function(mw_set_project_name_from_source_dir project_name)
	get_filename_component(tree_name "${CMAKE_SOURCE_DIR}" NAME)
	if(${tree_name} STREQUAL dev)
		get_filename_component(tree_name "${CMAKE_SOURCE_DIR}/.." ABSOLUTE)
		get_filename_component(tree_name "${tree_name}" NAME)
	endif()
	# check if we have a sane tree name
	if(${tree_name} MATCHES "^[a-zA-Z0-9_-]+$")
		set(${project_name} build_${tree_name} PARENT_SCOPE)
	else()
		# there are weird characters in the tree name, don't use it as project name
		set(${project_name} mySolution PARENT_SCOPE)
	endif()
endfunction()

macro(subdirlist result curdir)
  file(GLOB children RELATIVE ${curdir} ${curdir}/*)
  set(dirlist "")
  foreach(child ${children})
    if(IS_DIRECTORY ${curdir}/${child})
      list(APPEND dirlist ${child})
    endif()
  endforeach()
  set(${result} ${dirlist})
endmacro()

function(add_all_successors_of_current_directory)
	subdirlist(SUBDIRS ${CMAKE_CURRENT_LIST_DIR})

	foreach(subdir ${SUBDIRS})
		add_subdirectory(${subdir})		
	endforeach()
endfunction()

function(add_external_lib lib_name)
	set(PATH_TO_COMMON_LIBS "C:/Users/Andrew/source/c++libraries")
    add_subdirectory("${PATH_TO_COMMON_LIBS}/${lib_name}" "${CMAKE_BINARY_DIR}/external_libraries/${lib_name}")
    set_target_properties(${lib_name} PROPERTIES FOLDER "external_libraries")
endfunction()

function(remove_definition target definition)
	set(defs)
	# message(${defs})
	add_compile_definitions(blah)
	# target_compile_definitions(${target} PUBLIC blah)
	get_target_property(defs ${target} COMPILE_DEFINITIONS)
	message(${defs})
	# list(FILTER defs EXCLUDE REGEX [[^NOMINMAX$]])
	list(FILTER defs EXCLUDE REGEX "^${definition}$")
	set_property(TARGET ${target} PROPERTY COMPILE_DEFINITIONS ${defs})
endfunction()